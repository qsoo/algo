## 부분집합

- 부분 집합



- 예제 1) 재귀함수로 구현한 부분집합 구하기

  ```python
  # 기본구조
  def powerset(n:int, k:int):
      global cnt
      if n == k:
          for i in range(k):
              if visited[i] == 1:
                  print(ex[i], end=' ')
          print()
  
      else:
  				# 포함했을 때의 경우의 부분집합 구하는 부분
          visited[n] = 1
          powerset(n+1, k)
  				# 포함하지 않았을 때의 부분집합을 구하는 부분
          visited[n] = 0
          powerset(n+1, k)
  ```

  방문 여부를 체크할 수 있는 배열을 하나 생성해주고

  (주어진 데이터의 배열과 길이가 같게 만들어줘서 해당 원소를 사용했는지 안했는지 여부를 판단)

  배열의 길이가 N일 때 첫 원소를 포함하는 경우와 포함하지 않는 경우 모두

  $2^{(N-1)}$의 개수를 가지고 이것이 반복되어져서 나타나는 형태이기 때문에 재귀함수로 구현이 가능하다.



- 예제 2) 비트연산으로 부분집합 구하기

  ```python
  # 2. bit masking
  # 1. N: 정수의 개수, S: 합
  N, S = map(int, input().split())
  arr = list(map(int, input().split()))
  cnt = 0
  # 1. 전체 총 부분집합의 개수 2^N
  for i in range(1 << N):
      total = 0
  		# 2. 부분집합을 만들 수 있는 전체집합의 원소의 개수
      for j in range(N):
  				# 3. 해당 원소가 포함되었는지 여부 check
          if i & (1 << j):
              total += arr[j]
      if i and total == S:
          cnt += 1
  ```

  (1) 전체 구조 중에서 첫번째 for문의 부분은 전체 부분집합을 만들 수 있는 총 개수만큼 loop를 돈다

  이 말은 즉, 전체 개수만큼 탐색을 실시하겠다는 부분

  (2) 두번째 for문의 경우에는 부분집합을 찾을 전체 원소의 개수만큼 for문을 돌게 되는데 이는 전체 원소를 탐색하면서 포함되었는지 여부를 체크하기 위해 loop를 돌게된다

  (3) 가장 이해하기 힘든 부분이자 핵심 부분인데 `&` 연산을 통해 (여기서 쉽게 표현하자면 해당 원소가 부분집합에 포함되는지 여부 판단) `1 & 1 == 1` 이기 때문에 포함된 원소들을 찾아내는 작업을 하는 것을 뜻한다.

  example)

  0b001 & 0b001 == 0b001 이기 때문에(i == 1, j == 0 인 경우) A = [1, 2, 3]의 전체 집합에서 A[0]의 인덱스 위치에 있는 3만 포함하는 부분집합이 나오게 된다